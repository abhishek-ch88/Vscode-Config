{"ref":"22f6e20e-71a7-45b1-af75-2a1fd8f0c768","content":"{\"version\":1,\"machineId\":\"f2ee4920-d6c4-43cb-ad09-872a9ff51ba7\",\"content\":\"{\\\"binarySearch.code-snippets\\\":\\\"{\\\\n  // Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and\\\\n  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope\\\\n  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is\\\\n  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:\\\\n  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.\\\\n  // Placeholders with the same ids are connected.\\\\n  // Example:\\\\n  \\\\\\\"binary search\\\\\\\": {\\\\n    \\\\\\\"prefix\\\\\\\": \\\\\\\"binarySearch\\\\\\\",\\\\n    \\\\\\\"body\\\\\\\": [\\\\n      \\\\\\\"ll binarySearch(ll arr[], ll x, ll n)\\\\\\\",\\\\n      \\\\\\\"{\\\\\\\",\\\\n      \\\\\\\"   ll start = 0, end = n - 1;\\\\\\\",\\\\n      \\\\\\\"   ll mid = start + (end - start) / 2;\\\\\\\",\\\\n      \\\\\\\"   if(x < arr[0])\\\\\\\",\\\\n      \\\\\\\"       return 0;\\\\\\\",\\\\n      \\\\\\\"    if( x > arr[n-1])\\\\\\\",\\\\n      \\\\\\\"        return n;\\\\\\\",\\\\n      \\\\\\\"   while (start <= end)\\\\\\\",\\\\n      \\\\\\\"   {\\\\\\\",\\\\n      \\\\\\\"       if(arr[mid] < x && arr[mid + 1] > x)\\\\\\\",\\\\n      \\\\\\\"           return mid + 1;\\\\\\\",\\\\n      \\\\\\\"        if(arr[mid] < x)\\\\\\\",\\\\n      \\\\\\\"            start = mid + 1;\\\\\\\",\\\\n      \\\\\\\"        else\\\\\\\",\\\\n      \\\\\\\"        {\\\\\\\",\\\\n      \\\\\\\"            end = mid - 1;\\\\\\\",\\\\n      \\\\\\\"        }\\\\\\\",\\\\n      \\\\\\\"   }\\\\\\\",\\\\n      \\\\\\\"   return 0;\\\\\\\",\\\\n      \\\\\\\"}\\\\\\\"\\\\n    ],\\\\n    \\\\\\\"description\\\\\\\": \\\\\\\"binary search\\\\\\\"\\\\n  }\\\\n}\\\\n\\\",\\\"checkPeimw.code-snippets\\\":\\\"{\\\\n\\\\t\\\\\\\"checkPrime\\\\\\\": {\\\\n\\\\t\\\\t\\\\\\\"prefix\\\\\\\": \\\\\\\"checkPrime\\\\\\\",\\\\n\\\\t\\\\t\\\\\\\"body\\\\\\\": [\\\\n\\\\t\\\\t\\\\t\\\\\\\"bool isPrime(ll n)\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"{\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\tfor(i=2;i*i<=n;i++)\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\t{\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\t\\\\tif (n % i == 0)\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\t\\\\t\\\\treturn false;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\t}\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\treturn true;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"}\\\\\\\"\\\\n\\\\t\\\\t],\\\\n\\\\t\\\\t\\\\\\\"description\\\\\\\": \\\\\\\"checkPrime\\\\\\\"\\\\n\\\\t}\\\\n}\\\\n\\\",\\\"cpp.json\\\":\\\"{\\\\n\\\\t\\\\\\\"profesor\\\\\\\": {\\\\n\\\\t\\\\t\\\\\\\"body\\\\\\\": [\\\\n\\\\t\\\\t\\\\t\\\\\\\"/************\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"Author :- Profesor(Abhishek)\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"**********/\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#include <bits/stdc++.h>\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"using namespace std;\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define ll long long\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define fast ios_base::sync_with_stdio(0);cin.tie(0);\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define endl\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\\\\\\\\\\\\" , \\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"n\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define fori(i,a,b) for(ll i=a;i<b;i++)\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define forr(i,a,b) for(ll i=a;i>=b;i--)\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define forit(it,x) for (auto it=(x).begin();it!=(x).end(); it++)\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define all(x) (x).begin(),(x).end()\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define allr(x) (x).rbegin(),(x).rend()\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define eb emplace_back\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define pb push_back\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define mp make_pair\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define fi first\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define se second\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define sll set<ll>\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define vll vector<ll>\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define msl map<string,ll>\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define mll map<ll,ll>\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"ll i, j, k;\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"int main()\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"{\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"return 0;\\\\\\\\r\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"}\\\\\\\"\\\\n\\\\t\\\\t]\\\\n\\\\t}\\\\n}\\\",\\\"dfs.code-snippets\\\":\\\"{\\\\n\\\\t\\\\\\\"dfs\\\\\\\": {\\\\n\\\\t\\\\t\\\\\\\"prefix\\\\\\\": \\\\\\\"depthFirstSearch\\\\\\\",\\\\n\\\\t\\\\t\\\\\\\"body\\\\\\\": [\\\\n\\\\t\\\\t\\\\t\\\\\\\"vector<vector<int>> adj(MAXN); // graph represented as an adjacency list\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"vector<int> visited(MAXN);\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"void dfs(int v) {\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"    visited[v] = 1;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"    for (int u : adj[v]) {\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"        if (!visited[u])\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"            dfs(u);\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"    }\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"}\\\\\\\"\\\\n\\\\t\\\\t],\\\\n\\\\t\\\\t\\\\\\\"description\\\\\\\": \\\\\\\"dfs\\\\\\\"\\\\n\\\\t}\\\\n}\\\\n\\\",\\\"factor.code-snippets\\\":\\\"{\\\\n  \\\\\\\"factor\\\\\\\": {\\\\n  \\\\\\\"prefix\\\\\\\": \\\\\\\"factors\\\\\\\",\\\\n  \\\\\\\"body\\\\\\\": [\\\\n    \\\\\\\"vector<ll> factor()\\\\\\\",\\\\n    \\\\\\\"{\\\\\\\",\\\\n    \\\\\\\"    vll vec ,v;\\\\\\\",\\\\n    \\\\\\\"    for(i=1;i*i<=n;i++)\\\\\\\",\\\\n    \\\\\\\"    {\\\\\\\",\\\\n    \\\\\\\"        if(n%i==0)\\\\\\\",\\\\n    \\\\\\\"        {\\\\\\\",\\\\n    \\\\\\\"            v.pb(i);\\\\\\\",\\\\n    \\\\\\\"            if(i*i!=n)\\\\\\\",\\\\n    \\\\\\\"            {\\\\\\\",\\\\n    \\\\\\\"                vec.pb(n / i);\\\\\\\",\\\\n    \\\\\\\"            }\\\\\\\",\\\\n    \\\\\\\"        }\\\\\\\",\\\\n    \\\\\\\"    }\\\\\\\",\\\\n    \\\\\\\"    reverse(all(vec));\\\\\\\",\\\\n    \\\\\\\"    vec.insert(vec.begin(),v.begin(),v.end());\\\\\\\",\\\\n    \\\\\\\"    return v;\\\\\\\",\\\\n    \\\\\\\"}  \\\\\\\",\\\\n    \\\\\\\"  \\\\\\\"\\\\n  ],\\\\n  \\\\\\\"description\\\\\\\": \\\\\\\"factor\\\\\\\"\\\\n}\\\",\\\"gcdEuler.code-snippets\\\":\\\"{\\\\n  // Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and\\\\n  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope\\\\n  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is\\\\n  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:\\\\n  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.\\\\n  // Placeholders with the same ids are connected.\\\\n  // Example:\\\\n  \\\\\\\"GCD\\\\\\\": {\\\\n    \\\\\\\"prefix\\\\\\\": \\\\\\\"gcdEuler\\\\\\\",\\\\n    \\\\\\\"body\\\\\\\": [\\\\n      \\\\\\\"ll gcd(ll a, ll b)\\\\\\\",\\\\n      \\\\\\\"{\\\\\\\",\\\\n      \\\\\\\"    if(b==0)\\\\\\\",\\\\n      \\\\\\\"        return a;\\\\\\\",\\\\n      \\\\\\\"    return gcd(b,a%b)\\\\\\\",\\\\n      \\\\\\\"}\\\\\\\"\\\\n    ],\\\\n    \\\\\\\"description\\\\\\\": \\\\\\\"GCD\\\\\\\"\\\\n  }\\\\n}\\\\n\\\",\\\"pow.code-snippets\\\":\\\"{\\\\n\\\\t\\\\\\\"power\\\\\\\": {\\\\n\\\\t\\\\t\\\\\\\"prefix\\\\\\\": \\\\\\\"pow\\\\\\\",\\\\n\\\\t\\\\t\\\\\\\"body\\\\\\\": [\\\\n\\\\t\\\\t\\\\t\\\\\\\"ll binpow(ll a,ll b){\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\tll res=1;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\ta%=MOD;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\twhile(b>0){\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\t\\\\tif(b&1){res=res*a%MOD;}\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\t\\\\ta=a*a%MOD;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\t\\\\tb>>=1;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\t}\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\treturn res;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"}\\\\\\\"\\\\n\\\\t\\\\t],\\\\n\\\\t\\\\t\\\\\\\"description\\\\\\\": \\\\\\\"power\\\\\\\"\\\\n\\\\t}\\\\n}\\\\n\\\",\\\"power.code-snippets\\\":\\\"\\\",\\\"primefactor.code-snippets\\\":\\\"{\\\\n\\\\t\\\\\\\"primefactor\\\\\\\": {\\\\n\\\\t\\\\t\\\\\\\"prefix\\\\\\\": \\\\\\\"primefactor\\\\\\\",\\\\n\\\\t\\\\t\\\\\\\"body\\\\\\\": [\\\\n\\\\t\\\\t\\\\t\\\\\\\"template<class T> vector<pair<T,int>> factor(T x) { // x <= 10^{14} is fine\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"           vector<pair<T,int>> pri;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\" \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"             for (T i = 2; i*i <= x; ++i)\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"                     if (x % i == 0) {\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"              int t = 0;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"             while (x % i == 0) \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"                x /= i, t ++;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"           pri.pb({i, t});\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"       }\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\" \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"       if (x > 1) pri.pb({x,1});\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"       return pri;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"}\\\\\\\"\\\\n\\\\t\\\\t],\\\\n\\\\t\\\\t\\\\\\\"description\\\\\\\": \\\\\\\"primefactor\\\\\\\"\\\\n\\\\t}\\\\n\\\\n}\\\",\\\"printAdjList.code-snippets\\\":\\\"{\\\\n\\\\t\\\\\\\"printAdjList\\\\\\\": {\\\\n\\\\t\\\\t\\\\\\\"prefix\\\\\\\": \\\\\\\"printList\\\\\\\",\\\\n\\\\t\\\\t\\\\\\\"body\\\\\\\": [\\\\n\\\\t\\\\t\\\\t\\\\\\\"void printadjList(int n)\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"{\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"    for1(i, n+1)\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"    {\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"        cout << i << \\\\\\\\\\\\\\\" \\\\\\\\\\\\\\\";\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"        for (int u : adj[ i ])\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"            cout << u << \\\\\\\\\\\\\\\" \\\\\\\\\\\\\\\";\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"        cout << endl;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"    }\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"}\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\\\\"\\\\n\\\\t\\\\t],\\\\n\\\\t\\\\t\\\\\\\"description\\\\\\\": \\\\\\\"printAdjList\\\\\\\"\\\\n\\\\t}\\\\n}\\\\n\\\",\\\"profesor.code-snippets\\\":\\\"{\\\\n\\\\t// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and\\\\n\\\\t// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope\\\\n\\\\t// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is\\\\n\\\\t// used to trigger the snippet and the body will be expanded and inserted. Possible variables are:\\\\n\\\\t// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.\\\\n\\\\t// Placeholders with the same ids are connected.\\\\n\\\\t// Example:\\\\n\\\\t// \\\\\\\"Print to console\\\\\\\": {\\\\n\\\\t// \\\\t\\\\\\\"scope\\\\\\\": \\\\\\\"javascript,typescript\\\\\\\",\\\\n\\\\t// \\\\t\\\\\\\"prefix\\\\\\\": \\\\\\\"log\\\\\\\",\\\\n\\\\t// \\\\t\\\\\\\"body\\\\\\\": [\\\\n\\\\t// \\\\t\\\\t\\\\\\\"console.log('$1');\\\\\\\",\\\\n\\\\t// \\\\t\\\\t\\\\\\\"$2\\\\\\\"\\\\n\\\\t// \\\\t],\\\\n\\\\t// \\\\t\\\\\\\"description\\\\\\\": \\\\\\\"Log output to console\\\\\\\"\\\\n\\\\t// }\\\\n\\\\n\\\\t\\\\\\\"starting template\\\\\\\": {\\\\n\\\\t\\\\t\\\\\\\"prefix\\\\\\\": \\\\\\\"profesor\\\\\\\",\\\\n\\\\t\\\\t\\\\\\\"body\\\\\\\": [\\\\n\\\\t\\\\t\\\\t\\\\\\\"/************\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"Beautiful Codes are MUCH better than 'Shorter' ones !\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"Author :- Profesor(Abhishek)\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"$CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR  $CURRENT_HOUR.$CURRENT_MINUTE.$CURRENT_SECOND\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"**********/\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#include \\\\\\\\\\\\\\\"bits/stdc++.h\\\\\\\\\\\\\\\"\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"using namespace std;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define ll long long\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"ll i, j, k;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define fast ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define endl \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\"\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define test() long long test;cin>>test;while(test--)\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define watch(x) cout << (#x) << \\\\\\\\\\\\\\\" is \\\\\\\\\\\\\\\" << (x) << endl\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define for0(i, n) for (i = 0; i < n; i++)\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define for1(i, n) for (i = 1; i < n; i++)\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define loop(i,a,b) for(i=a;i<b;i++)\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define loopr(i,a,b) for(i=a;i>b;i--)\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define forit(it,x) for (auto it=(x).begin();it!=(x).end(); it++)\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define all(x) (x).begin(),(x).end()\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define allr(x) (x).rbegin(),(x).rend()\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define pb push_back\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define pf emplace_front\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define mp make_pair\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define fi first\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define se second\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define que_max priority_queue <int>\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define que_min priority_queue <int, vi, greater<int> >\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define isPowerOfTwo(S) (!(S & (S - 1)))\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define nearestPowerOfTwo(S) ((int)pow(2.0, (int)((log((double)S) / log(2.0)) + 0.5)))\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define sll set<ll>\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define vll vector<ll>\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define msl map<string,ll>\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define mll map<ll,ll>\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"#define MAXN 100001\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"int main()\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"{\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"     test()$1\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"   // cout << endl << \\\\\\\\\\\\\\\"time taken : \\\\\\\\\\\\\\\" << (float)clock() / CLOCKS_PER_SEC << \\\\\\\\\\\\\\\" secs\\\\\\\\\\\\\\\" << endl;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"    return 0;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"}\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"/************\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"// A QUITTER NEVER WINS __ AND __ A WINNER NEVER QUITS..\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"**********/\\\\\\\"\\\\n\\\\t\\\\t],\\\\n\\\\t\\\\t\\\\\\\"description\\\\\\\": \\\\\\\"starting template\\\\\\\"\\\\n\\\\t}\\\\n}\\\\n\\\",\\\"segmented sieve.code-snippets\\\":\\\"{\\\\n  // Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and\\\\n  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope\\\\n  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is\\\\n  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:\\\\n  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.\\\\n  // Placeholders with the same ids are connected.\\\\n  // Example:\\\\n  \\\\\\\"segmented sieve\\\\\\\": {\\\\n    \\\\\\\"prefix\\\\\\\": \\\\\\\"segmentedSieve\\\\\\\",\\\\n    \\\\\\\"body\\\\\\\": [\\\\n      \\\\\\\"vector<bool> segmentedSieve(long long L, long long R) {\\\\\\\",\\\\n      \\\\\\\"    // generate all primes up to sqrt(R)\\\\\\\",\\\\n      \\\\\\\"    long long lim = sqrt(R);\\\\\\\",\\\\n      \\\\\\\"    vector<bool> mark(lim + 1, true);\\\\\\\",\\\\n      \\\\\\\"    mark[0]=mark[1]=false;\\\\\\\",\\\\n      \\\\\\\"    vector<long long> primes;\\\\\\\",\\\\n      \\\\\\\"    primes.emplace_back(2);\\\\\\\",\\\\n      \\\\\\\"    for (long long i = 3; i <= lim; i+=2) {\\\\\\\",\\\\n      \\\\\\\"        if (mark[i]) {\\\\\\\",\\\\n      \\\\\\\"            primes.emplace_back(i);\\\\\\\",\\\\n      \\\\\\\"            for (long long j = i * i; j <= lim; j += i)\\\\\\\",\\\\n      \\\\\\\"                mark[j] = false;\\\\\\\",\\\\n      \\\\\\\"        }\\\\\\\",\\\\n      \\\\\\\"    }\\\\\\\",\\\\n      \\\\\\\"\\\\\\\",\\\\n      \\\\\\\"    vector<bool> isPrime(R - L + 1, true);\\\\\\\",\\\\n      \\\\\\\"    for (long long i : primes)\\\\\\\",\\\\n      \\\\\\\"        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)\\\\\\\",\\\\n      \\\\\\\"            isPrime[j - L] = false;\\\\\\\",\\\\n      \\\\\\\"    if (L == 1)\\\\\\\",\\\\n      \\\\\\\"        isPrime[0] = false;\\\\\\\",\\\\n      \\\\\\\"    return isPrime;\\\\\\\",\\\\n      \\\\\\\"\\\\\\\",\\\\n      \\\\\\\"//representation in int main if if(p[i-l])cout << i;\\\\\\\",\\\\n      \\\\\\\"}\\\\\\\"\\\\n    ],\\\\n    \\\\\\\"description\\\\\\\": \\\\\\\"segmented sieve\\\\\\\"\\\\n  }\\\\n}\\\\n\\\",\\\"setBitNumber.code-snippets\\\":\\\"\\\\n\\\\\\\"setBitNumber\\\\\\\": {\\\\n  \\\\\\\"prefix\\\\\\\": \\\\\\\"\\\\\\\",\\\\n  \\\\\\\"body\\\\\\\": [\\\\n    \\\\\\\"int setBitNumber(int n) \\\\\\\",\\\\n    \\\\\\\"{ \\\\\\\",\\\\n    \\\\\\\"  \\\\\\\",\\\\n    \\\\\\\"    // To find the position \\\\\\\",\\\\n    \\\\\\\"    // of the most significant \\\\\\\",\\\\n    \\\\\\\"    // set bit \\\\\\\",\\\\n    \\\\\\\"    int k = (int)(log2(n)); \\\\\\\",\\\\n    \\\\\\\"  \\\\\\\",\\\\n    \\\\\\\"    // To return the the value \\\\\\\",\\\\n    \\\\\\\"    // of the number with set \\\\\\\",\\\\n    \\\\\\\"    // bit at k-th position \\\\\\\",\\\\n    \\\\\\\"    return (int)(pow(2, k)); \\\\\\\",\\\\n    \\\\\\\"} \\\\\\\"\\\\n  ],\\\\n  \\\\\\\"description\\\\\\\": \\\\\\\"setBitNumber\\\\\\\"\\\\n}\\\\n\\\\n\\\",\\\"sieve.code-snippets\\\":\\\"{\\\\n\\\\t// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and\\\\n\\\\t// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope\\\\n\\\\t// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is\\\\n\\\\t// used to trigger the snippet and the body will be expanded and inserted. Possible variables are:\\\\n\\\\t// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.\\\\n\\\\t// Placeholders with the same ids are connected.\\\\n\\\\t// Example:\\\\n\\\\t\\\\\\\"sieve of erastothenes\\\\\\\": {\\\\n\\\\t\\\\t\\\\\\\"prefix\\\\\\\": \\\\\\\"simpleSieve\\\\\\\",\\\\n\\\\t\\\\t\\\\\\\"body\\\\\\\": [\\\\n\\\\t\\\\t\\\\t\\\\\\\"vll primes;\\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"void SieveOfEratosthenes(int n) \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"{ \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"    bool prime[n+1]; \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"    memset(prime, true, sizeof(prime)); \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"  \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"    for (int p=2; p*p<=n; p++) \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"    { \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"        if (prime[p] == true) \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"        { \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"            for (int i=p*p; i<=n; i += p) \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"                prime[i] = false; \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"        } \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"    }  \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"    for (int p=2; p<=n; p++) \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"       if (prime[p]) \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"          primes.push_back(p); \\\\\\\",\\\\n\\\\t\\\\t\\\\t\\\\\\\"} \\\\\\\"\\\\n\\\\t\\\\t],\\\\n\\\\t\\\\t\\\\\\\"description\\\\\\\": \\\\\\\"sieve of erastothenes\\\\\\\"\\\\n\\\\t}\\\\n}\\\\n\\\"}\"}"}